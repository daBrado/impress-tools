#!/usr/bin/env ruby

require 'logger'
require 'savon'
require 'json'

LOG_FORMATTER = Proc.new { |sev,d,p,msg| "#{DateTime.now.strftime('%F %T')} #{Process::pid} #{Thread::current.object_id.to_s(16)} #{sev}: #{msg}\n" }

SAVON_LOG = Logger.new(STDERR)
SAVON_LOG.level = Logger::WARN
SAVON_LOG.formatter = LOG_FORMATTER
HTTPI.logger = SAVON_LOG

module Nokogiri
  module XML
    class Node
      def content_value()
        if self.content.empty?
          return nil
        elsif self.content == 'false'
          return false
        elsif self.content == 'true'
          return true
        else
          return self.content
        end
      end
      def collapse()
        result = inner_collapse
        return result ? (result.kind_of?(Array) ? result : [result]) : []
      end
      def inner_collapse()
        case element_children.size
        when 0
          return self.content_value
        when 1
          return first_element_child.inner_collapse
        else
          array = []
          hash = {}
          self.element_children.each do |c|
            if c.name == "item" && !c.xpath('key').empty? && !c.xpath('value').empty?
              hash[c.xpath('key')[0].content.to_sym] = c.xpath('value')[0].content_value
            else
              array << c.inner_collapse
            end
          end
          raise Exception.new "hashy and non-hashy" if !hash.empty? && !array.empty?
          return (!hash.empty?) ? hash : array
        end
      end
    end
  end
end

module IMPReSS
  extend self
  WSDL = "https://www.mousephenotype.org/impress/soap/server?wsdl"
  MAX_TASKS = 20
  RECHECK_INTERVAL = 360
  RETRY_INTERVAL = 10
  LOG = Logger.new STDERR
  LOG.level = Logger::INFO
  LOG.formatter = LOG_FORMATTER

  class Client < Savon::Client
    def initialize
      super(wsdl: WSDL, logger: SAVON_LOG, pretty_print_xml: true, raise_errors: false)
    end
    def call(cmd, message=nil)
      begin
        response = super(cmd, message: message)
        sleep RETRY_INTERVAL if response.http_error?
      end until response && !response.http_error?
      return response.doc.collapse
    end
  end

  class DatabaseDownloader
    def initialize()
      @data = {}
      @client = IMPReSS::Client.new
      @tasks = Queue.new
      @threads = []
      @mutex = Mutex.new
    end
    def uptodate?()
      return File.exists? json_filename @client.call(:get_when_last_modified)[0]
    end
    def json_filename(date=nil)
      date = @data[:when_last_modified] if !date
      return "impress.#{date}.json"
    end
    def download()
      LOG.info "Downloading IMPReSS database"
      LOG.debug @client.operations
      @data = {}
      @data[:when_last_modified] = @client.call(:get_when_last_modified)[0]
      @tasks << Proc.new { get_pipelines() }
      Array.new(MAX_TASKS) { Thread.new { handle_tasks } }.each { |t| t.join }
      if @client.call(:get_when_last_modified)[0] == @data[:when_last_modified]
        File.new(json_filename, 'w').write(JSON::pretty_generate(@data))
        File.unlink "impress.json" if File.symlink? "impress.json"
        File.symlink(json_filename, "impress.json") if !File.exists? "impress.json"
      else
        LOG.error "Aborting; database was modified while we were downloading it"
      end
      LOG.info "IMPReSS database download complete"
    end
    def handle_tasks()
      LOG.debug "Handle tasks"; n=0
      @mutex.synchronize { @threads << Thread.current }
      until @tasks.empty? && @tasks.num_waiting == @threads.count { |t| t != Thread.current && t.alive? }
        task = @tasks.pop
        task.call if task
        n+=1 if task
      end
      @mutex.synchronize { @threads.delete Thread.current }
      @tasks << nil
      LOG.debug "Handled #{n} tasks"
    end
    def get_pipelines()
      LOG.debug "Getting pipeline keys"
      @client.call(:get_pipeline_keys).each do |k|
        @tasks << Proc.new { get_pipeline(k.to_sym) }
      end
    end
    def get_pipeline(pipeline_key)
      LOG.debug "Getting pipeline #{pipeline_key}"
      pipeline = @client.call(:get_pipeline, pipeline_key: pipeline_key)[0]
      @mutex.synchronize { @data[pipeline_key] = pipeline }
      @mutex.synchronize { @data[pipeline_key][:procedures] = [] }
      @tasks << Proc.new { get_procedures(pipeline_key) }
    end
    def get_procedures(pipeline_key)
      LOG.debug "Getting procedure keys for pipeline #{pipeline_key}"
      @client.call(:get_procedures, pipeline_key: pipeline_key).each do |procedure|
        procedure_key = procedure[:procedure_key].to_sym
        @mutex.synchronize { @data[pipeline_key][:procedures] << procedure_key }
        if claim_key procedure_key
          LOG.debug "Recording procedure #{procedure_key}"
          @mutex.synchronize { @data[procedure_key] = procedure }
          @tasks << Proc.new { get_parameters(procedure_key) }
        else
          LOG.debug "Already found procedure #{procedure_key}"
        end
      end
    end
    def get_parameters(procedure_key)
      @mutex.synchronize { @data[procedure_key][:parameters] = [] }
      LOG.debug "Getting parameters for procedure #{procedure_key}"
      @client.call(:get_parameters, procedure_key: procedure_key).each do |parameter|
        @mutex.synchronize { @data[procedure_key][:parameters] << parameter[:parameter_key].to_sym }
        @tasks << Proc.new { add_parameter(parameter) }
      end
    end
    def add_parameter(parameter)
      parameter_key = parameter[:parameter_key].to_sym
      if claim_key parameter_key
        LOG.debug "Recording parameter #{parameter_key}"
        @mutex.synchronize { @data[parameter_key] = parameter }
        get_parameter_extra(parameter_key, :increments)
        get_parameter_extra(parameter_key, :options)
        get_parameter_extra(parameter_key, :mp_terms)
        get_parameter_extra(parameter_key, :eq_terms)
      else
        LOG.debug "Already found parameter #{parameter_key}"
      end
    end
    def get_parameter_extra(parameter_key, name)
      @tasks << Proc.new do
        LOG.debug "Getting #{name} for parameter #{parameter_key}"
        value = @client.call(('get_parameter_'+name.to_s).to_sym, parameter_key: parameter_key)
        @mutex.synchronize { @data[parameter_key][name] = value }
      end
    end
    def claim_key(key)
      @mutex.synchronize do
        return false if @data.include? key
        @data[key] = nil
        return true
      end
    end
  end

  def uptodate?()
    if DatabaseDownloader.new.uptodate?
      LOG.info "Local IMPReSS database is up to date"
      return 0
    else
      LOG.info "Local IMPReSS database is out of date"
      return 1
    end
  end

  def download()
    DatabaseDownloader.new.download
  end

  def update()
    if DatabaseDownloader.new.uptodate?
      LOG.info "IMPReSS database is already up to date"
    else
      DatabaseDownloader.new.download
    end
  end

  def daemon()
    while true
      update()
      LOG.info "Waiting for #{RECHECK_INTERVAL} seconds before checking again"
      sleep RECHECK_INTERVAL
    end
  end
end

case ARGV[0]
when "uptodate"
  IMPReSS::uptodate?
when "download"
  IMPReSS::download
when "update"
  IMPReSS::update
when "daemon"
  IMPReSS::daemon
else
  STDERR.puts "Usage: #{$0} uptodate | download | update | daemon"
end
