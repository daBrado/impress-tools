#!/usr/bin/env ruby

$DEBUG=nil

require 'logger'
require 'savon'
require 'json'

SAVON_LOG = Logger.new(STDERR)
SAVON_LOG.level = Logger::WARN
HTTPI.logger = SAVON_LOG

module Nokogiri
  module XML
    class Node
      def content_value()
        if self.content.empty?
          return nil
        elsif self.content == 'false'
          return false
        elsif self.content == 'true'
          return true
        else
          return self.content
        end
      end
      def collapse()
        result = inner_collapse
        return result ? (result.kind_of?(Array) ? result : [result]) : []
      end
      def inner_collapse()
        case element_children.size
        when 0
          return self.content_value
        when 1
          return first_element_child.inner_collapse
        else
          array = []
          hash = {}
          self.element_children.each do |c|
            if c.name == "item" && !c.xpath('key').empty? && !c.xpath('value').empty?
              hash[c.xpath('key')[0].content.to_sym] = c.xpath('value')[0].content_value
            else
              array << c.inner_collapse
            end
          end
          raise Exception.new "hashy and non-hashy" if !hash.empty? && !array.empty?
          return (!hash.empty?) ? hash : array
        end
      end
    end
  end
end

module IMPReSS
  extend self
  WSDL = "https://www.mousephenotype.org/impress/soap/server?wsdl"
  RECHECK_INTERVAL = 360
  RETRY_INTERVAL = 10
  LOG = Logger.new STDERR
  LOG.level = Logger::DEBUG

  class Client < Savon::Client
    def call(cmd, message=nil)
      response = nil
      while !response
        begin
          response = super(cmd, message: message)
        rescue Savon::HTTPError => e
          LOG.warn "Got HTTP Error #{e}; retrying in #{RETRY_INTERVAL} seconds"
          sleep RETRY_INTERVAL
          LOG.warn "Retrying SOAP call"
        end
      end
      return response.doc.collapse
    end
  end

  class Database
    def initialize()
      @data = {}
      @client = nil
      @queue = Queue.new
    end
    def update()
      @data = {}
      @client = IMPReSS::Client.new(wsdl: WSDL, logger: SAVON_LOG, pretty_print_xml: true)
      @data[:when_last_modified] = @client.call(:get_when_last_modified)[0]
      jsonfilename = "impress.#{@data[:when_last_modified]}.json"
      if File.exists? jsonfilename
        LOG.info "JSON file for current version (#{@data[:when_last_modified]}) already exists; no update needed"
        return
      end
      LOG.info "Proceeding to download updated IMPReSS database"
      LOG.debug @client.operations
      download()
      when_last_modified = @client.call(:get_when_last_modified)[0]
      if when_last_modified == @data[:when_last_modified]
        File.new(jsonfilename, 'w').write(JSON::pretty_generate(@data))
        File.unlink "impress.json" if File.symlink? "impress.json"
        File.symlink(jsonfilename, "impress.json") if !File.exists? "impress.json"
      else
        LOG.error "Database was modified while we downloaded it! Aborting."
      end
      LOG.info "IMPReSS database download complete"
    end
    def download()
      @queue << Proc.new { get_pipelines() }
      while !@queue.empty?
        task = @queue.pop
        task.call
      end
    end
    def get_pipelines()
      LOG.debug "Getting pipeline keys"
      @client.call(:get_pipeline_keys).each do |k|
        @queue << Proc.new { get_pipeline(k.to_sym) }
      end
    end
    def get_pipeline(pipeline_key)
      LOG.debug "Getting pipeline #{pipeline_key}"
      @data[pipeline_key] = @client.call(:get_pipeline, pipeline_key: pipeline_key)[0]
      @data[pipeline_key][:procedures] = []
      @queue << Proc.new { get_procedures(pipeline_key) }
    end
    def get_procedures(pipeline_key)
      LOG.debug "Getting procedure keys for pipeline #{pipeline_key}"
      @client.call(:get_procedures, pipeline_key: pipeline_key).each do |procedure|
        procedure_key = procedure[:procedure_key].to_sym
        @data[pipeline_key][:procedures] << procedure_key
        if !@data.include? procedure_key
          LOG.debug "Recording procedure #{procedure_key}"
          @data[procedure_key] = procedure
          @queue << Proc.new { get_parameters(procedure_key) }
        else
          LOG.debug "Already found procedure #{procedure_key}"
        end
      end
    end
    def get_parameters(procedure_key)
      @data[procedure_key][:parameters] = []
      LOG.debug "Getting parameters for procedure #{procedure_key}"
      @client.call(:get_parameters, procedure_key: procedure_key).each do |parameter|
        @data[procedure_key][:parameters] << parameter[:parameter_key].to_sym
        @queue << Proc.new { add_parameter(parameter) }
      end
    end
    def add_parameter(parameter)
      parameter_key = parameter[:parameter_key].to_sym
      if !@data.include? parameter_key
        LOG.debug "Recording parameter #{parameter_key}"
        @data[parameter_key] = parameter
        get_parameter_extra(parameter_key, :increments)
        get_parameter_extra(parameter_key, :options)
        get_parameter_extra(parameter_key, :mp_terms)
        get_parameter_extra(parameter_key, :eq_terms)
      else
        LOG.debug "Already found parameter #{parameter_key}"
      end
    end
    def get_parameter_extra(parameter_key, name)
      @queue << Proc.new do
        LOG.debug "Getting #{name} for parameter #{parameter_key}"
        @data[parameter_key][name] = @client.call(('get_parameter_'+name.to_s).to_sym, parameter_key: parameter_key)
      end
    end
  end

  def update()
    Database.new.update()
  end

  def daemon()
    while true
      update()
      LOG.info "Waiting for #{RECHECK_INTERVAL} seconds before checking again"
      sleep RECHECK_INTERVAL
    end
  end
end

case ARGV[0]
when "update"
  IMPReSS::update
when "daemon"
  IMPReSS::daemon
else
  STDERR.puts "Usage: #{$0} update | daemon"
end
